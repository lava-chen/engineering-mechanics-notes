# Java 渐进论 1

---

> 笔记的来源：[CS 61B-2024 春季的课程](https://sp24.datastructur.es/)
> 课程主要内容：数据结构与算法分析
> 课程运用语言：Java

这个课有[**6 个 Homework，10 个 Lab，9 个 Project**](https://github.com/Berkeley-CS61B/skeleton-sp24)。其中第一个 project 是一个完整的 2024 游戏的实现，很有意思。**此文章对应的是课程 12 节的内容。主要讲述算法**

此笔记对应资源：[CS 61B 课本资源](https://cs61b-2.gitbook.io/cs61b-textbook/13.-asymptotics-i/13.1-an-introduction-to-asymptotic-analysis)

## 高效的程序

高效的程序可以从两方面考虑：

1. **编程成本**
   1. 需要多长时间编写程序？
   2. 阅读修改代码是否容易？
   3. 程序的可维护性，扩展性如何？
2. **执行成本**
   1. 时间复杂度：你的程序执行需要多长时间？
   2. 空间复杂度：你的程序需要多少内存？

## 判断数组是否有重复元素

为了理解接下的内容，我们考虑判断数组是否有重复元素的问题。

```java
List<Integer> example = [-3, -1, 2, 4, 4, 8, 10, 12];
```

**一种简单的算法 dup1**是比较每对元素。在上面的例子中，我们将列表中的每个元素与 -3 进行比较，然后与 -1、2 等进行比较。如果发现重复元素，则返回 true。

```java
public static boolean dup1(int[] A) {
  for (int i = 0; i < A.length; i += 1) {
    for (int j = i + 1; j < A.length; j += 1) {
      if (A[i] == A[j]) {
         return true;
      }
    }
  }
  return false;
}
```

**更好的算法 dup2**是利用列表的排序特性！将列表排序后，我们不必比较每对元素，而是可以将每个元素与其旁边的元素进行比较。

```java
public static boolean dup2(int[] A) {
  for (int i = 0; i < A.length - 1; i += 1) {
    if (A[i] == A[i + 1]) {
      return true;
    }
  }
  return false;
}
```

## 算法性能表达

**1. 利用时间衡量**

- 使用物理秒表（不推荐）。

- 使用 Unix 的内置 time 命令。

- 使用具有类的普林斯顿标准库 stopwatch。

使用其中任何一种方法都会显示（具有不同精度级别，取决于是否选择了物理秒表路径），随着输入大小的增加，`dup1`需要更长的时间才能完成，而`dup2`完成速度相对大致相同。

这个方法看起来已经很好了，但它有许多缺陷。例如，如果输入数组非常大，则`dup1`可能会花费很长的时间来处理，而`dup2`则可能仍然很快。此外，时间能表达的信息太模糊不精准，所以我们需要寻找另一种方法。

**2.用操作次数来替代实际运行时间**


